\section{Introduction}
\subsection{Programmable Electronic Medical Systems}
Programmable electronic medical systems (PEMS) are as the names implies systems that can be programmed. Their goal is to provide medical assistance to a patient. A benefit of such a system is that they to not require constant supervision. The systems can be programmed with the logic required for its successful application. A common example of a PEMS is a insulin pump. PEMS are classified into different categories based on what damages they could cause. A higher classification means that the device must abide to stricter regulation.

\subsubsection{Safety}
The perhaps most challenging part of creating a PEMS is ensuring its safety. The devices must obey a multitude of requirements to ensure that they are safe to use. As a system bug or failure could cause a loss of life, products that are released to market must have gone through strict procedures that detect and prevent defective devices from reaching the market. As there is no one thing that can be done to ensure safety, the development of a device needs to be documented. This documentation help show that every effort has been made to ensure the safety of a device.

One of the ways that can be used to verify a devices safety is by certification. A company producing a PEMS could send their software, along with their process for creating it, to a certification company that can certify the safety of the product. The certifiers are able to trace through the development of the device and determine if the process for creating the device adheres to the strict safety requirements required. 

The disadvantage of all these security features are that they greatly increase the time and effort required for developing the product. Naturally this leads to a higher end price that the end users are going to have to pay. This is an expected outcome, but it is far from being desirable. Users that require these devices might not be able to afford the end price and might have a lower quality of life. A potential solution to both of these problems, safety and cost, would be to use a formal language such as Event-B.

\subsection{Event-B}
Event-B is a modelling language that allows us to define a model and assert if the model upholds invariants that we define. We can define either Machines or Contexts. The context contain the static information of the system such as Sets, constants and axioms. The machines however define variables, events and invariants. The events modify the variables of the machine. While the invariants tells us something about the machine. Event can contain guards that prohibit the event from being called. By the use of guards, we can limit the availability of events. The limitations of the events means that we can add invariants into our model. For all invariants defined, proof obligations are created for all the events of the model. The proof obligations can only be discharged if we are able to prove that the given event upholds all the models invariants. For example, our model could define a variable ``x''. An invariant we have could state that a predicate ``P'' always holds for the variable ``x'' ie. ``P(x)'' is always true. To uphold this invariant, all events that modify ``x'' can have a guard that ensures that any new value for ``x'' will satisfy ``P(x')''. The invariants that we add can be directly related to the systems requirements. This means we can extract our models invariants from the systems requirements and check if our model satisfies them. If our model satisfies the invariants, we can say that we have proved that it is correct with regards to the requirements. Being able to write these invariants requires thought on how you model the system. Modelling decisions must be made that help write the invariants required. The benefit of using such a modelling language is that we can provide these models to a certification company. The certifier will be able to look at the model and have an easier job of verifying safety as invariants are provided and proved.

\subsubsection{Code Generation}
What is perhaps the strongest selling point of Event-B is the code generation. After having a complete model, we can transform the model into machine code. This process is for the most part automatic, but would normally entail some form of ``gluing''. Unlike some modelling languages where the model and machine code are two completely separated entities, they have a close relation in Event-B. This gives us more confidence that the invariants in the model are also present in the machine code.

The hope of using Event-B will hopefully mean that the process of creating new PEMS will be simplified. Reduced cost while maintaining the safety of the system. However, creating a Event-B model is a non-trivial problem. Many decisions made during modelling require a deep understanding of the system being modelled. It is not uncommon to restart the process of modelling a system. This is often due to initial abstractions of the system not being easily refined into more concrete events.

\subsection{Co-modelling - Discrete and Continuous}
There exist two types of systems: discrete and continuous systems. An easy way to distinguish the two is to remember that discrete machines can be represented with finite number of bits. For example a boolean that is either 0 or 1 is a discrete variable. Throwing a 6-sided dice is also discrete as there are exactly 6 possibilities. Continuous variables however require an infinite amount of bits to represent. Typically these are variables that deal with real world physics. As an example, imagine a bucket of apples. We have two pieces of information from this bucket: the number of whole apples and their total weight. We can imagine that we have 10 apples and they weigh a total of 1 kg. However, it is highly unlikely that we have exactly 1 kg of apples. We could have 1.1 or 1.0000001 kgs of apples. However, we can be certain that we have exactly 10 whole apples.

Co-modelling is the combination of using a discrete system together with a continuous one. Typically, some electronic controller is the discrete system while the physical components, or environment, is the continuous one. We can imagine a temperature sensor connected to a controller that is reporting the temperature. The sensor is constantly, continuously, sending new readings to the controller. The controller however only reads the new temperature at some interval. 

Event-B does not natively support co-modelling yet, but a new version has been planned. Hybrid Event-B plans to combine discrete systems with continuous systems. The benefit is clear, as we will no longer need to fake or simulate continuous events, but actually have them. The perhaps most interesting part is the fact of an in-built 

     

A insulin pump is connected to a patient and regulates the level of insulin in the blood. This pump is required when a patients body is no longer able to successfully regulate its insulin levels itself. This means that the insulin pump must be able to inject insulin whenever it deems it necessary. As with all systems, errors can and do occur. However, errors in a PEMS are unacceptable and must be avoided at all cost. 